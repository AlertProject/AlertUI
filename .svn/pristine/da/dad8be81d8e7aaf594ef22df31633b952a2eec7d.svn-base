//returns the value of a CSS attribute
function getCssValue(clazz, attribute) {
	var $p = $("<p class='" + clazz + "'></p>").hide().appendTo("body");
	var value = $p.css(attribute);
	$p.remove();
	return value;
}

(function() {
  Renderer = function(canvas) {
    var canvas = $(canvas).get(0);
    var ctx = canvas.getContext("2d");
    var gfx = arbor.Graphics(canvas);
    var particleSystem = null;
	
	//read CSS attributes
	var selectedTextClr = getCssValue("selected-node", "color");
	var selectedBoxClr = getCssValue("selected-node", "background-color");
	var neighbourTextClr = getCssValue("neighbour-node", "color");
	var neighbourBoxClr = getCssValue("neighbour-node", "background-color");
	
	if (selectedTextClr == null) selectedTextClr = "yellow";
	if (selectedBoxClr == null) selectedBoxClr = "rgba(30, 116, 255, .6)";
	if (neighbourTextClr == null) neighbourTextClr = "white";
	if (neighbourBoxClr == null) selectedBoxClr = "rgba(62, 189, 255, .6)";

    var that = {
		minAlpha: .2,
		init:function(system) {
			particleSystem = system;
			particleSystem.screenSize(canvas.width, canvas.height); 
			particleSystem.screenPadding(40);

			that.initMouseHandling();
		},

		redraw:function() {
			if (!particleSystem) return;

			gfx.clear(); // convenience Æ’: clears the whole canvas rect

			// draw the nodes & save their bounds for edge drawing
			var nodeBoxes = {};
			particleSystem.eachNode(function(node, pt) {
				//calculate the font size
				var data = node.data;
				
				var fontSize = node.data.size;
				var textColor = "black";
				
				ctx.font = fontSize + "px Helvetica";
			
				// calculate the position for the box
				var label = data.label;
				var w = ctx.measureText(label).width + 10;
				pt.x = Math.floor(pt.x);
				pt.y = Math.floor(pt.y);
				
				//draw the selected nodes and their neighbours differently
				if (data.selected || data.neighboursSelected > 0) {
					//selected nodes are colored a bit differently than their neighbours
					var boxColor;
					if (data.selected) {
						boxColor = selectedBoxClr;
						textColor = selectedTextClr;
					} else {
						boxColor = neighbourBoxClr;
						textColor = neighbourTextClr;
					}
				
					var color = boxColor;
					var margin = 8;
					var h = fontSize + margin;
					
					//draw a box
					ctx.fillStyle = color;
					gfx.rect(pt.x - w/2, pt.y - margin, w, h, 4, {fill:ctx.fillStyle});
					nodeBoxes[node.name] = [pt.x-w/2, pt.y-11, w, 22];
				} else {
					nodeBoxes[node.name] = [pt.x-w/2, pt.y-11, w, 22];
				}
				
				ctx.textAlign = "center";
				ctx.fillStyle = textColor;
				ctx.fillText(label, pt.x, pt.y+fontSize/2);
			});

			// draw the edges
			particleSystem.eachEdge(function(edge, pt1, pt2){
				//adjust the edge opacity based on the number of times it appears
				var alpha = edge.data.count == 0 ? that.minAlpha : Math.max(.2, 1 - 1/edge.data.count);
				var color = "rgba(85, 85, 85, " + alpha + ")";

				if (!color || (""+color).match(/^[ \t]*$/)) color = null;

				// find the start point
				var tail = intersect_line_box(pt1, pt2, nodeBoxes[edge.source.name]);
				var head = intersect_line_box(tail, pt2, nodeBoxes[edge.target.name]);

				ctx.save() ;
					ctx.beginPath();
					ctx.lineWidth = 1;
					ctx.strokeStyle = (color) ? color : "#cccccc";
					ctx.fillStyle = color;

					ctx.moveTo(tail.x, tail.y);
					ctx.lineTo(head.x, head.y);
					ctx.stroke();
				ctx.restore();

				// draw an arrowhead if this is a -> style edge
				if (edge.data.directed){
					ctx.save();
						// move to the head position of the edge we just drew
						var wt = 1;
						var arrowLength = 6 + wt;
						var arrowWidth = 2 + wt;
						ctx.fillStyle = (color) ? color : "#cccccc";
						ctx.translate(head.x, head.y);
						ctx.rotate(Math.atan2(head.y - tail.y, head.x - tail.x));

						// delete some of the edge that's already there (so the point isn't hidden)
						ctx.clearRect(-arrowLength/2,-wt/2, arrowLength/2,wt);

						// draw the chevron
						ctx.beginPath();
						ctx.moveTo(-arrowLength, arrowWidth);
						ctx.lineTo(0, 0);
						ctx.lineTo(-arrowLength, -arrowWidth);
						ctx.lineTo(-arrowLength * 0.8, -0);
						ctx.closePath();
						ctx.fill();
					ctx.restore();
				}
			});		
		},

		initMouseHandling:function(){
			// no-nonsense drag and drop (thanks springy.js)
			selected = null;
			nearest = null;
			var dragged = null;
			var oldmass = 1;

			// set up a handler object that will initially listen for mousedowns then
			// for moves and mouseups while dragging
			var handler = {
				selectedPrev: null,
				wasDragged: false,
				
				select: function (e) {
					var pos = $(canvas).offset();
					_mouseP = arbor.Point(e.pageX-pos.left, e.pageY-pos.top);
					selected = nearest = dragged = particleSystem.nearest(_mouseP);
				},
				
				clicked: function(e) {
					handler.select(e);
					//_mouseP = arbor.Point(e.pageX-pos.left, e.pageY-pos.top);
					//selected = nearest = dragged = particleSystem.nearest(_mouseP);

					if (dragged.node !== null) dragged.node.fixed = true;

					$(canvas).bind('mousemove', handler.dragged);
					$(window).bind('mouseup', handler.dropped);

					return false;
				},
				dragged:function(e){
					//var old_nearest = nearest && nearest.node._id;
					var pos = $(canvas).offset();
					var s = arbor.Point(e.pageX-pos.left, e.pageY-pos.top);

					if (!nearest) return;
					if (dragged !== null && dragged.node !== null) {
						var p = particleSystem.fromScreen(s);
						dragged.node.p = {x:p.x, y:p.y};
					}
					
					handler.wasDragged = true;

					return true;
				},

				dropped:function(e){
					if (dragged===null || dragged.node===undefined) return;
					if (dragged.node !== null) dragged.node.fixed = false;
					dragged.node.tempMass = 1000;
					
					// clear the previous selection
					if (!handler.wasDragged) {
						if (handler.selectedPrev != null && handler.selectedPrev.node._id != selected.node._id
								&& handler.selectedPrev.node.data.selected) {
							var data = handler.selectedPrev.node.data;
							data.selected = false;
							for (var i = 0; i < data.neighbours.length; i++) {
								var neighData = data.neighbours[i].data;
								neighData.neighboursSelected--;
							}
						}
						
						//make the node and neighbours selected
						var data = selected.node.data;
						if (data.selected == null || !data.selected) {
							data.selected = true;
							var neighbours = data.neighbours;
							
							for (var i = 0; i < neighbours.length; i++) {
								var neighbour = neighbours[i];
								var neighData = neighbour.data;
								
								neighData.neighboursSelected++;
							}
						} else {
							data.selected = false;
							var neighbours = data.neighbours;
							
							for (var i = 0; i < neighbours.length; i++) {
								var neighbour = neighbours[i];
								var neighData = neighbour.data;
								
								if (neighData.neighboursSelected > 0)
									neighData.neighboursSelected--;
							}
						}
						handler.selectedPrev = selected;
					}
					
					handler.wasDragged = false;
					dragged = null;
					selected = null;
					$(canvas).unbind('mousemove', handler.dragged);
					$(window).unbind('mouseup', handler.dropped);
					_mouseP = null;
					return false;
				}
			};
			$(canvas).mousedown(handler.clicked);
			$(canvas).dblclick(function (e) {
				handler.select(e);
				alert('works');
			});
		}
    };

    // helpers for figuring out where to draw arrows (thanks springy.js)
    var intersect_line_line = function(p1, p2, p3, p4) {
		var denom = ((p4.y - p3.y)*(p2.x - p1.x) - (p4.x - p3.x)*(p2.y - p1.y));
		if (denom === 0) return false; // lines are parallel
		var ua = ((p4.x - p3.x)*(p1.y - p3.y) - (p4.y - p3.y)*(p1.x - p3.x)) / denom;
		var ub = ((p2.x - p1.x)*(p1.y - p3.y) - (p2.y - p1.y)*(p1.x - p3.x)) / denom;

		if (ua < 0 || ua > 1 || ub < 0 || ub > 1)  return false;
		return arbor.Point(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y));
    };

    var intersect_line_box = function(p1, p2, boxTuple) {
		var p3 = {x:boxTuple[0], y:boxTuple[1]},
        w = boxTuple[2],
        h = boxTuple[3]

		var tl = {x: p3.x, y: p3.y};
		var tr = {x: p3.x + w, y: p3.y};
		var bl = {x: p3.x, y: p3.y + h};
		var br = {x: p3.x + w, y: p3.y + h};

		return intersect_line_line(p1, p2, tl, tr) ||
            intersect_line_line(p1, p2, tr, br) ||
            intersect_line_line(p1, p2, br, bl) ||
            intersect_line_line(p1, p2, bl, tl) ||
            false
    }

    return that
  }    
  
})()